## 튜닝의 종류
# 디자인 튜닝 : 데이터를 저장하는 논리적구조인 컬렉션의 설계문제
# 문장 튜닝 : 개발자의 쿼리 문제
# 아키텍처 튜닝 : 샤딩, 리프리카셋의 다양한 문제의 대처방법
# 인스턴스 튜닝 : 메모리가 적절히 할당 되지 못했을때 대처방법
# 하드웨어 튜닝 : 운영체제에 대한 성능튜닝

################################################################
## 성능 튜닝
# 디자인 튜닝
# 대용량 데이터의 컬렉션의 경우 최초 익스텐트의 크기를 충분하게 할당하여 설계해야함
# 전체컬렉션을 스캔하는 경우 익스텐트가 큰게 유리하고 인덱스 스캔이 자주 발생하는 경우 익스텐트를 작게 설계하는게 유리함
# 익스텐트 크기가 작으면 새로운 익스텐트가 할당받을 때마다 지연현상이 발생함
# 이러한 문제점을 해소하기 위해서는 충분한 물리적인 설계가 요구됨
# 해당 컬렉션에 초당 얼마나 많은 빅데이터가 저장될 것인지 비즈니스 룰에 대한 분석이 필요함
# 이것을 기반으로 많은 데이터를 저장, 관리할 것인지에 대한 데이터 발생량을 파악하여 적절한 익스텐트 크기를 결정하는 것이 중요한 성능포인트가 될 수 있음

# 컬렉션과 컬렉션 간의 업무적관계가 밀접한 경우에는 내장 또는 확장
# 밀접하지 않은 경우에는 Linking Document방법으로 설계함
# 컴파운드 인덱스를 설계할 때 필드의 우선순서는 자주 검색되거나 검색 조건이 유리한 필드를 선행 필드로 선택해야 성능이 유리함
# 복합키 인덱스의 경우 어떤필드를 기준으로 생성할지, 나머지 필드들의 우선위는 어떻게 결정할 것인지 등이 인덱스 성능을 좌우하게됨

## 복합키 인덱스를 생성할때 각 필드의 우선순위를 결정하는 기준
# 자주 검색되는 조건으로 사용되는 필드를 선행필드로 선택
# 분포도가 좋은 필드를 선행필드로 선택
#  데이터양이 적은 필드를 선택
# 동등조건으로 검색되는 필드를 선택

################################################################
## 문장 튜닝
# 개발자의 모든 쿼리문장은 로그정보가 저장됨(Profiling System)
# Explan()를 통해 Full Collection Scan되는 문장을 분석할 수 있음
# Key에 대한 업데이트는 Index구조에 대한 Update도 발생함
# Key는 되도록 수정, 삽입, 삭제가 빈번하지 않은 필드로 생성하는것이 좋음
# 가급적 수정, 삭제, 입력이 자주 발생하는 필드인 경우에는 인덱스를 생성하지 말아야함
# 빅데이터에 대한 빠른 Update를 위해 충분한 익스텐트 공간을 확보해야함
# 인덱스의 빠른 생성을 위해 Background Index를 생성해야함
# 기업에서 발생하는 그래픽데이터는 양이많고 크기 때문에 응답시간이 초과할 수 밖에 없음
# 이를 고려하고 설계해야함

################################################################.
## Profile 시스템
# MongoDB는 사용자가 실행하는 모든 문장들에 대한 로그정보를 Profiling 기능을 통해 지원함
# Profiling은 최초 환경설정이 필요
db.commandHelp("profile")
# 이전 설정정보
db.setProfileingLevel(2)
# 현재 설정정보
db.setProfilingLevel()
# 클라이언트에서 실행되었던 쿼리 문장 출력 (모든 로그 출력)
db.system.profile.find()
# 실행시간이 0.0005초이상 소요된 쿼리 문장들만 추출
db.system.profile.find( { millis : {$gte : 5} } )

## Profiling 재생성 및 관리
# Profiling을 통해 생성되는 로그정보는 MongoDB내 system.profile컬렉션에 저장되는데 이공간을 관리하는 방법을 알아봄
# 로그정보는 비주기적으로 관리해야함
# 재생성을위해 환경을 0으로 설정
db.setProfilingLevel(0)
# Profile Collection 삭제
db.system.profile.drop()
# Profile Collection 재생성
db.createCollection( "system.profile", {capped : true, size : 4000000} )
# Profile 컬렉션 상태 확인
db.system.profile.stats()

################################################################
## Explain 함수
# SQL문 실행계획을 분석하고 성능 튜닝을 위해 Explain 함수를 사용
# empno필드의 인덱스를 이용한 실행계획 출력
db.employees.find( {empno : 7369}, {empno : 1} ).explain()

################################################################
## 아키텍쳐 튜닝
# Mongo의 리프리카셋영역과 사용자의 비즈니스 영역과 관련된 기능은 분리해서 구축해야함
# 불필요하게 하나의 서버에 다양한 기능 설정을 하면 성능이 저하될 수 밖에 없음
# 초당 몇 만건 이상의 데이터가 저장되는 빅데이터 환경에서 하나의 싱글노드로 운영하는 것이 효율성이 떨어짐
# 이런 경우를 위해 샤드시스템이 존재
# 여러대의 서버를 이용하여 샤드시스템을 구축하면 빠른 쓰기 뿐만아니라 균등분산을 통한 시스템 성능을 향상 시킬수 있음

## 샤드 서버의 추가를 고려해야하는경우
# 하나의 싱글 노드가 저장공간이 부족한 경우
# Active상태의 WorkingSet이 전체 RAM공간의 90%를 초과하는 경우
# 싱글노드에 DB-Lock이 집중되는 Write-Scale을 감당하기 힘든 경우

# 리프리카셋의 슬레이브 서버는 백업 및 데이터분석작업은 마스터데이터베이스를 통해 작업을 수행해야함
# 하나의 서버에는 하나의 Mongod.exe 인스턴스만 활성화 함

################################################################
## 인스턴스 튜닝
# 문장튜닝을하고 개선되지 않는 경우에 인스턴스영역에 대한 튜닝을 함
# Mongo의 Resident영역이 시스템 전체 메모리 영역의 90%이상 점유하게 되는 경우 성능 지연현상이 발생
# 인스턴스의 효율성을 위해 최적화된 읽기/쓰기가 가능하도록 문장을 최적화 해야함

# Document를 저장하는 문법은 2가지임 (SAVE, UPDATE SET절)
# Document 전체 필드를 수정할때는 SAVE문을 사용하지만 특정필드만 변경할때는 성능지연이 발생함
# Resident영역을 최소화 시켜 인스턴스 영역에 대한 성능 향상을 고려해야함
# 인접성이 높아질 수 있도록 컬렉션을 설계하고 데이터를 저장함
# 유사한 성격의 데이터를 인접한 데이터영역에 저장함

# SSD를 사용하여 하드디스크 장치에의 불필요한 물리적 IO문제를 적극적으로 대처함
# 메모리 맵 캐시영역의 적정 메모리 크기는 10GB ( 64bit시스템 권장 )
# 단일 CPU환경은 CPU가 과부화되면 성능에 영향을 미치므로 다중 CPU 환경에서 구축함
# 샤딩 시스템을 구축하여 충분한 분산처리가 가능하게 함

